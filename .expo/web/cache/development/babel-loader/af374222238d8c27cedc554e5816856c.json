{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseUpdateArgs = exports.mergeFieldPathData = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _FieldPath = _interopRequireDefault(require(\"../FieldPath\"));\n\nvar _utils = require(\"../../../utils\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar buildFieldPathData = function buildFieldPathData(segments, value) {\n  if (segments.length === 1) {\n    return (0, _defineProperty2.default)({}, segments[0], value);\n  }\n\n  return (0, _defineProperty2.default)({}, segments[0], buildFieldPathData(segments.slice(1), value));\n};\n\nvar mergeFieldPathData = function mergeFieldPathData(data, segments, value) {\n  if (segments.length === 1) {\n    return _objectSpread(_objectSpread({}, data), {}, (0, _defineProperty2.default)({}, segments[0], value));\n  }\n\n  if (data[segments[0]]) {\n    return _objectSpread(_objectSpread({}, data), {}, (0, _defineProperty2.default)({}, segments[0], mergeFieldPathData(data[segments[0]], segments.slice(1), value)));\n  }\n\n  return _objectSpread(_objectSpread({}, data), {}, (0, _defineProperty2.default)({}, segments[0], buildFieldPathData(segments.slice(1), value)));\n};\n\nexports.mergeFieldPathData = mergeFieldPathData;\n\nvar parseUpdateArgs = function parseUpdateArgs(args, methodName) {\n  var data = {};\n\n  if (args.length === 1) {\n    if (!(0, _utils.isObject)(args[0])) {\n      throw new Error(methodName + \" failed: If using a single update argument, it must be an object.\");\n    }\n\n    var _args = (0, _slicedToArray2.default)(args, 1);\n\n    data = _args[0];\n  } else if (args.length % 2 === 1) {\n    throw new Error(methodName + \" failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.\");\n  } else {\n    for (var i = 0; i < args.length; i += 2) {\n      var key = args[i];\n      var value = args[i + 1];\n\n      if ((0, _utils.isString)(key)) {\n        data[key] = value;\n      } else if (key instanceof _FieldPath.default) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(methodName + \" failed: Argument at index \" + i + \" must be a string or FieldPath\");\n      }\n    }\n  }\n\n  return data;\n};\n\nexports.parseUpdateArgs = parseUpdateArgs;","map":{"version":3,"sources":["/Users/alheresh/trend-mobile/my-trend-new/node_modules/react-native-firebase/dist/modules/firestore/utils/index.js"],"names":["buildFieldPathData","segments","value","length","slice","mergeFieldPathData","data","parseUpdateArgs","args","methodName","Error","i","key","FieldPath","_segments"],"mappings":";;;;;;;;;;;AAAA;;AACA;;;;;;AAEA,IAAMA,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,QAAD,EAAWC,KAAX,EAAqB;AAC9C,MAAID,QAAQ,CAACE,MAAT,KAAoB,CAAxB,EAA2B;AACzB,6CACGF,QAAQ,CAAC,CAAD,CADX,EACiBC,KADjB;AAGD;;AAED,2CACGD,QAAQ,CAAC,CAAD,CADX,EACiBD,kBAAkB,CAACC,QAAQ,CAACG,KAAT,CAAe,CAAf,CAAD,EAAoBF,KAApB,CADnC;AAGD,CAVD;;AAaO,IAAMG,kBAAkB,GAAG,SAArBA,kBAAqB,CAACC,IAAD,EAAOL,QAAP,EAAiBC,KAAjB,EAA2B;AAC3D,MAAID,QAAQ,CAACE,MAAT,KAAoB,CAAxB,EAA2B;AACzB,2CAAYG,IAAZ,yCACGL,QAAQ,CAAC,CAAD,CADX,EACiBC,KADjB;AAGD;;AAED,MAAII,IAAI,CAACL,QAAQ,CAAC,CAAD,CAAT,CAAR,EAAuB;AACrB,2CAAYK,IAAZ,yCACGL,QAAQ,CAAC,CAAD,CADX,EACiBI,kBAAkB,CAACC,IAAI,CAACL,QAAQ,CAAC,CAAD,CAAT,CAAL,EAAoBA,QAAQ,CAACG,KAAT,CAAe,CAAf,CAApB,EAAuCF,KAAvC,CADnC;AAGD;;AAED,yCAAYI,IAAZ,yCACGL,QAAQ,CAAC,CAAD,CADX,EACiBD,kBAAkB,CAACC,QAAQ,CAACG,KAAT,CAAe,CAAf,CAAD,EAAoBF,KAApB,CADnC;AAGD,CAhBM;;;;AAiBA,IAAMK,eAAe,GAAG,SAAlBA,eAAkB,CAACC,IAAD,EAAOC,UAAP,EAAsB;AACnD,MAAIH,IAAI,GAAG,EAAX;;AAEA,MAAIE,IAAI,CAACL,MAAL,KAAgB,CAApB,EAAuB;AACrB,QAAI,CAAC,qBAASK,IAAI,CAAC,CAAD,CAAb,CAAL,EAAwB;AACtB,YAAM,IAAIE,KAAJ,CAAaD,UAAb,uEAAN;AACD;;AAHoB,6CAKZD,IALY;;AAKpBF,IAAAA,IALoB;AAMtB,GAND,MAMO,IAAIE,IAAI,CAACL,MAAL,GAAc,CAAd,KAAoB,CAAxB,EAA2B;AAChC,UAAM,IAAIO,KAAJ,CAAaD,UAAb,iHAAN;AACD,GAFM,MAEA;AACL,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACL,MAAzB,EAAiCQ,CAAC,IAAI,CAAtC,EAAyC;AACvC,UAAMC,GAAG,GAAGJ,IAAI,CAACG,CAAD,CAAhB;AACA,UAAMT,KAAK,GAAGM,IAAI,CAACG,CAAC,GAAG,CAAL,CAAlB;;AAEA,UAAI,qBAASC,GAAT,CAAJ,EAAmB;AACjBN,QAAAA,IAAI,CAACM,GAAD,CAAJ,GAAYV,KAAZ;AACD,OAFD,MAEO,IAAIU,GAAG,YAAYC,kBAAnB,EAA8B;AACnCP,QAAAA,IAAI,GAAGD,kBAAkB,CAACC,IAAD,EAAOM,GAAG,CAACE,SAAX,EAAsBZ,KAAtB,CAAzB;AACD,OAFM,MAEA;AACL,cAAM,IAAIQ,KAAJ,CAAaD,UAAb,mCAAqDE,CAArD,oCAAN;AACD;AACF;AACF;;AAED,SAAOL,IAAP;AACD,CA3BM","sourcesContent":["import FieldPath from '../FieldPath';\nimport { isObject, isString } from '../../../utils';\n\nconst buildFieldPathData = (segments, value) => {\n  if (segments.length === 1) {\n    return {\n      [segments[0]]: value\n    };\n  }\n\n  return {\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n}; // eslint-disable-next-line import/prefer-default-export\n\n\nexport const mergeFieldPathData = (data, segments, value) => {\n  if (segments.length === 1) {\n    return { ...data,\n      [segments[0]]: value\n    };\n  }\n\n  if (data[segments[0]]) {\n    return { ...data,\n      [segments[0]]: mergeFieldPathData(data[segments[0]], segments.slice(1), value)\n    };\n  }\n\n  return { ...data,\n    [segments[0]]: buildFieldPathData(segments.slice(1), value)\n  };\n};\nexport const parseUpdateArgs = (args, methodName) => {\n  let data = {};\n\n  if (args.length === 1) {\n    if (!isObject(args[0])) {\n      throw new Error(`${methodName} failed: If using a single update argument, it must be an object.`);\n    }\n\n    [data] = args;\n  } else if (args.length % 2 === 1) {\n    throw new Error(`${methodName} failed: The update arguments must be either a single object argument, or equal numbers of key/value pairs.`);\n  } else {\n    for (let i = 0; i < args.length; i += 2) {\n      const key = args[i];\n      const value = args[i + 1];\n\n      if (isString(key)) {\n        data[key] = value;\n      } else if (key instanceof FieldPath) {\n        data = mergeFieldPathData(data, key._segments, value);\n      } else {\n        throw new Error(`${methodName} failed: Argument at index ${i} must be a string or FieldPath`);\n      }\n    }\n  }\n\n  return data;\n};"]},"metadata":{},"sourceType":"script"}