{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regenerator = _interopRequireDefault(require(\"@babel/runtime/regenerator\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _events = require(\"../../utils/events\");\n\nvar _native = require(\"../../utils/native\");\n\nvar _Transaction = _interopRequireDefault(require(\"./Transaction\"));\n\nvar transactionId = 0;\n\nvar generateTransactionId = function generateTransactionId() {\n  return transactionId++;\n};\n\nvar TransactionHandler = function () {\n  function TransactionHandler(firestore) {\n    (0, _classCallCheck2.default)(this, TransactionHandler);\n    this._pending = {};\n    this._firestore = firestore;\n\n    _events.SharedEventEmitter.addListener((0, _events.getAppEventName)(this._firestore, 'firestore_transaction_event'), this._handleTransactionEvent.bind(this));\n  }\n\n  (0, _createClass2.default)(TransactionHandler, [{\n    key: \"_add\",\n    value: function _add(updateFunction) {\n      var _this = this;\n\n      var id = generateTransactionId();\n      var meta = {\n        id: id,\n        updateFunction: updateFunction,\n        stack: new Error().stack.split('\\n').slice(2).join('\\n')\n      };\n      this._pending[id] = {\n        meta: meta,\n        transaction: new _Transaction.default(this._firestore, meta)\n      };\n      return new Promise(function (resolve, reject) {\n        (0, _native.getNativeModule)(_this._firestore).transactionBegin(id);\n\n        meta.resolve = function (r) {\n          resolve(r);\n\n          _this._remove(id);\n        };\n\n        meta.reject = function (e) {\n          reject(e);\n\n          _this._remove(id);\n        };\n      });\n    }\n  }, {\n    key: \"_remove\",\n    value: function _remove(id) {\n      (0, _native.getNativeModule)(this._firestore).transactionDispose(id);\n      delete this._pending[id];\n    }\n  }, {\n    key: \"_handleTransactionEvent\",\n    value: function _handleTransactionEvent(event) {\n      switch (event.type) {\n        case 'update':\n          this._handleUpdate(event);\n\n          break;\n\n        case 'error':\n          this._handleError(event);\n\n          break;\n\n        case 'complete':\n          this._handleComplete(event);\n\n          break;\n      }\n    }\n  }, {\n    key: \"_handleUpdate\",\n    value: function _handleUpdate(event) {\n      var id, _this$_pending$id, meta, transaction, updateFunction, reject, finalError, updateFailed, pendingResult, possiblePromise;\n\n      return _regenerator.default.async(function _handleUpdate$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              id = event.id;\n\n              if (this._pending[id]) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\", this._remove(id));\n\n            case 3:\n              _this$_pending$id = this._pending[id], meta = _this$_pending$id.meta, transaction = _this$_pending$id.transaction;\n              updateFunction = meta.updateFunction, reject = meta.reject;\n\n              transaction._prepare();\n\n              _context.prev = 6;\n              possiblePromise = updateFunction(transaction);\n\n              if (!(!possiblePromise || !possiblePromise.then)) {\n                _context.next = 12;\n                break;\n              }\n\n              finalError = new Error('Update function for `firestore.runTransaction(updateFunction)` must return a Promise.');\n              _context.next = 15;\n              break;\n\n            case 12:\n              _context.next = 14;\n              return _regenerator.default.awrap(possiblePromise);\n\n            case 14:\n              pendingResult = _context.sent;\n\n            case 15:\n              _context.next = 21;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](6);\n              updateFailed = true;\n              finalError = _context.t0;\n\n            case 21:\n              if (!(updateFailed || finalError)) {\n                _context.next = 23;\n                break;\n              }\n\n              return _context.abrupt(\"return\", reject(finalError));\n\n            case 23:\n              transaction._pendingResult = pendingResult;\n              return _context.abrupt(\"return\", (0, _native.getNativeModule)(this._firestore).transactionApplyBuffer(id, transaction._commandBuffer));\n\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, [[6, 17]], Promise);\n    }\n  }, {\n    key: \"_handleError\",\n    value: function _handleError(event) {\n      var id = event.id,\n          error = event.error;\n      var meta = this._pending[id].meta;\n\n      if (meta && error) {\n        var code = error.code,\n            message = error.message;\n        var errorWithStack = new Error(message);\n        errorWithStack.code = code;\n        errorWithStack.stack = \"Error: \" + message + \"\\n\" + meta.stack;\n        meta.reject(errorWithStack);\n      }\n    }\n  }, {\n    key: \"_handleComplete\",\n    value: function _handleComplete(event) {\n      var id = event.id;\n      var _this$_pending$id2 = this._pending[id],\n          meta = _this$_pending$id2.meta,\n          transaction = _this$_pending$id2.transaction;\n\n      if (meta) {\n        var pendingResult = transaction._pendingResult;\n        meta.resolve(pendingResult);\n      }\n    }\n  }]);\n  return TransactionHandler;\n}();\n\nexports.default = TransactionHandler;","map":{"version":3,"sources":["/Users/alheresh/trend-mobile/my-trend-new/node_modules/react-native-firebase/dist/modules/firestore/TransactionHandler.js"],"names":["transactionId","generateTransactionId","TransactionHandler","firestore","_pending","_firestore","SharedEventEmitter","addListener","_handleTransactionEvent","bind","updateFunction","id","meta","stack","Error","split","slice","join","transaction","Transaction","Promise","resolve","reject","transactionBegin","r","_remove","e","transactionDispose","event","type","_handleUpdate","_handleError","_handleComplete","_prepare","possiblePromise","then","finalError","pendingResult","updateFailed","_pendingResult","transactionApplyBuffer","_commandBuffer","error","code","message","errorWithStack"],"mappings":"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","sourcesContent":["/**\n * \n * Firestore Transaction representation wrapper\n */\nimport { getAppEventName, SharedEventEmitter } from '../../utils/events';\nimport { getNativeModule } from '../../utils/native';\nimport Transaction from './Transaction';\nlet transactionId = 0;\n/**\n * Uses the push id generator to create a transaction id\n * @returns {number}\n * @private\n */\n\nconst generateTransactionId = () => transactionId++;\n\n/**\n * @class TransactionHandler\n */\nexport default class TransactionHandler {\n  constructor(firestore) {\n    this._pending = {};\n    this._firestore = firestore;\n    SharedEventEmitter.addListener(getAppEventName(this._firestore, 'firestore_transaction_event'), this._handleTransactionEvent.bind(this));\n  }\n  /**\n   * -------------\n   * INTERNAL API\n   * -------------\n   */\n\n  /**\n   * Add a new transaction and start it natively.\n   * @param updateFunction\n   */\n\n\n  _add(updateFunction) {\n    const id = generateTransactionId(); // $FlowExpectedError: Transaction has to be populated\n\n    const meta = {\n      id,\n      updateFunction,\n      stack: new Error().stack.split('\\n').slice(2).join('\\n')\n    };\n    this._pending[id] = {\n      meta,\n      transaction: new Transaction(this._firestore, meta)\n    }; // deferred promise\n\n    return new Promise((resolve, reject) => {\n      getNativeModule(this._firestore).transactionBegin(id);\n\n      meta.resolve = r => {\n        resolve(r);\n\n        this._remove(id);\n      };\n\n      meta.reject = e => {\n        reject(e);\n\n        this._remove(id);\n      };\n    });\n  }\n  /**\n   * Destroys a local instance of a transaction meta\n   *\n   * @param id\n   * @private\n   */\n\n\n  _remove(id) {\n    getNativeModule(this._firestore).transactionDispose(id);\n    delete this._pending[id];\n  }\n  /**\n   * -------------\n   *    EVENTS\n   * -------------\n   */\n\n  /**\n   * Handles incoming native transaction events and distributes to correct\n   * internal handler by event.type\n   *\n   * @param event\n   * @returns {*}\n   * @private\n   */\n\n\n  _handleTransactionEvent(event) {\n    // eslint-disable-next-line default-case\n    switch (event.type) {\n      case 'update':\n        this._handleUpdate(event);\n\n        break;\n\n      case 'error':\n        this._handleError(event);\n\n        break;\n\n      case 'complete':\n        this._handleComplete(event);\n\n        break;\n    }\n  }\n  /**\n   * Handles incoming native transaction update events\n   *\n   * @param event\n   * @private\n   */\n\n\n  async _handleUpdate(event) {\n    const {\n      id\n    } = event; // abort if no longer exists js side\n\n    if (!this._pending[id]) return this._remove(id);\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n    const {\n      updateFunction,\n      reject\n    } = meta; // clear any saved state from previous transaction runs\n\n    transaction._prepare();\n\n    let finalError;\n    let updateFailed;\n    let pendingResult; // run the users custom update functionality\n\n    try {\n      const possiblePromise = updateFunction(transaction); // validate user has returned a promise in their update function\n      // TODO must it actually return a promise? Can't find any usages of it without one...\n\n      if (!possiblePromise || !possiblePromise.then) {\n        finalError = new Error('Update function for `firestore.runTransaction(updateFunction)` must return a Promise.');\n      } else {\n        pendingResult = await possiblePromise;\n      }\n    } catch (exception) {\n      // exception can still be falsey if user `Promise.reject();` 's with no args\n      // so we track the exception with a updateFailed boolean to ensure no fall-through\n      updateFailed = true;\n      finalError = exception;\n    } // reject the final promise and remove from native\n    // update is failed when either the users updateFunction\n    // throws an error or rejects a promise\n\n\n    if (updateFailed || finalError) {\n      // $FlowExpectedError: Reject will always be present\n      return reject(finalError);\n    } // capture the resolved result as we'll need this\n    // to resolve the runTransaction() promise when\n    // native emits that the transaction is final\n\n\n    transaction._pendingResult = pendingResult; // send the buffered update/set/delete commands for native to process\n\n    return getNativeModule(this._firestore).transactionApplyBuffer(id, transaction._commandBuffer);\n  }\n  /**\n   * Handles incoming native transaction error events\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleError(event) {\n    const {\n      id,\n      error\n    } = event;\n    const {\n      meta\n    } = this._pending[id];\n\n    if (meta && error) {\n      const {\n        code,\n        message\n      } = error; // build a JS error and replace its stack\n      // with the captured one at start of transaction\n      // so it's actually relevant to the user\n\n      const errorWithStack = new Error(message); // $FlowExpectedError: code is needed for Firebase errors\n\n      errorWithStack.code = code; // $FlowExpectedError: stack should be a stack trace\n\n      errorWithStack.stack = `Error: ${message}\\n${meta.stack}`; // $FlowExpectedError: Reject will always be present\n\n      meta.reject(errorWithStack);\n    }\n  }\n  /**\n   * Handles incoming native transaction complete events\n   *\n   * @param event\n   * @private\n   */\n\n\n  _handleComplete(event) {\n    const {\n      id\n    } = event;\n    const {\n      meta,\n      transaction\n    } = this._pending[id];\n\n    if (meta) {\n      const pendingResult = transaction._pendingResult; // $FlowExpectedError: Resolve will always be present\n\n      meta.resolve(pendingResult);\n    }\n  }\n\n}"]},"metadata":{},"sourceType":"script"}